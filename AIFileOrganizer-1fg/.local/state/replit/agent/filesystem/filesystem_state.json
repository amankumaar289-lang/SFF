{"file_contents":{"server/routes.ts":{"content":"import { Router, Request, Response } from \"express\";\nimport { z } from \"zod\";\nimport { insertOrganizationSchema, insertGeneratedPolicySchema } from \"@shared/schema\";\nimport type { IStorage } from \"./storage\";\n\nexport function createRouter(storage: IStorage): Router {\n  const router = Router();\n\n  router.get(\"/api/organizations\", async (req: Request, res: Response) => {\n    try {\n      const organizations = await storage.getOrganizations();\n      res.json(organizations);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch organizations\" });\n    }\n  });\n\n  router.get(\"/api/organizations/:id\", async (req: Request, res: Response) => {\n    try {\n      const id = parseInt(req.params.id);\n      if (isNaN(id)) {\n        return res.status(400).json({ error: \"Invalid organization ID\" });\n      }\n      \n      const organization = await storage.getOrganization(id);\n      if (!organization) {\n        return res.status(404).json({ error: \"Organization not found\" });\n      }\n      \n      res.json(organization);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch organization\" });\n    }\n  });\n\n  router.post(\"/api/organizations\", async (req: Request, res: Response) => {\n    try {\n      const validated = insertOrganizationSchema.parse(req.body);\n      const organization = await storage.createOrganization(validated);\n      res.status(201).json(organization);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({ error: \"Validation failed\", details: error.errors });\n      }\n      res.status(500).json({ error: \"Failed to create organization\" });\n    }\n  });\n\n  router.get(\"/api/policy-sections\", async (req: Request, res: Response) => {\n    try {\n      let sections = await storage.getPolicySections();\n      \n      const { accountingType, industry } = req.query;\n      \n      if (accountingType) {\n        sections = sections.filter(section => {\n          if (accountingType === \"budget\") {\n            return section.budgetAccounting;\n          } else if (accountingType === \"accounting\") {\n            return section.businessAccounting;\n          }\n          return true;\n        });\n      }\n      \n      if (industry && typeof industry === \"string\") {\n        sections = sections.filter(section => {\n          if (!section.industrySpecific) {\n            return true;\n          }\n          return section.industries?.includes(industry) || false;\n        });\n      }\n      \n      res.json(sections);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch policy sections\" });\n    }\n  });\n\n  router.get(\"/api/generated-policies\", async (req: Request, res: Response) => {\n    try {\n      const policies = await storage.getGeneratedPolicies();\n      res.json(policies);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch generated policies\" });\n    }\n  });\n\n  router.post(\"/api/generated-policies\", async (req: Request, res: Response) => {\n    try {\n      const validated = insertGeneratedPolicySchema.parse(req.body);\n      \n      const organization = await storage.getOrganization(validated.organizationId);\n      if (!organization) {\n        return res.status(400).json({ error: \"Organization not found\" });\n      }\n      \n      const allSections = await storage.getPolicySections();\n      const validSectionIds = allSections.map(s => s.id);\n      const invalidSections = validated.selectedSections.filter(\n        id => !validSectionIds.includes(id)\n      );\n      \n      if (invalidSections.length > 0) {\n        return res.status(400).json({ \n          error: \"Invalid policy section IDs\", \n          invalidIds: invalidSections \n        });\n      }\n      \n      const policy = await storage.createGeneratedPolicy(validated);\n      res.status(201).json(policy);\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return res.status(400).json({ error: \"Validation failed\", details: error.errors });\n      }\n      res.status(500).json({ error: \"Failed to create generated policy\" });\n    }\n  });\n\n  router.get(\"/api/generated-policies/:id\", async (req: Request, res: Response) => {\n    try {\n      const id = parseInt(req.params.id);\n      if (isNaN(id)) {\n        return res.status(400).json({ error: \"Invalid policy ID\" });\n      }\n      \n      const policy = await storage.getGeneratedPolicy(id);\n      if (!policy) {\n        return res.status(404).json({ error: \"Generated policy not found\" });\n      }\n      \n      const organization = await storage.getOrganization(policy.organizationId);\n      if (!organization) {\n        return res.status(404).json({ error: \"Associated organization not found\" });\n      }\n      \n      const allSections = await storage.getPolicySections();\n      const selectedSections = allSections.filter(section => \n        policy.selectedSections.includes(section.id)\n      );\n      \n      const response = {\n        ...policy,\n        organization,\n        sections: selectedSections\n      };\n      \n      res.json(response);\n    } catch (error) {\n      res.status(500).json({ error: \"Failed to fetch generated policy\" });\n    }\n  });\n\n  return router;\n}\n","size_bytes":5150},"server/storage.ts":{"content":"import type { \n  Organization, \n  InsertOrganization,\n  PolicySection,\n  InsertPolicySection,\n  GeneratedPolicy,\n  InsertGeneratedPolicy \n} from \"@shared/schema\";\n\nexport interface IStorage {\n  getOrganizations(): Promise<Organization[]>;\n  getOrganization(id: number): Promise<Organization | null>;\n  createOrganization(data: InsertOrganization): Promise<Organization>;\n  getPolicySections(): Promise<PolicySection[]>;\n  getPolicySection(id: number): Promise<PolicySection | null>;\n  getGeneratedPolicies(): Promise<GeneratedPolicy[]>;\n  createGeneratedPolicy(data: InsertGeneratedPolicy): Promise<GeneratedPolicy>;\n  getGeneratedPolicy(id: number): Promise<GeneratedPolicy | null>;\n}\n\nexport class MemStorage implements IStorage {\n  private organizations: Organization[] = [\n    {\n      id: 1,\n      name: \"Департамент природы и охраны окружающей среды города Москвы\",\n      inn: \"7700258755\",\n      kpp: \"770101001\",\n      accountingType: \"budget\",\n      industry: \"Окружающая среда\",\n      centralizedOffice: \"ГКУ «ЦБ природоохраны»\"\n    },\n    {\n      id: 2,\n      name: \"Департамент финансов города Москвы\",\n      inn: \"7707079518\",\n      kpp: \"770101001\",\n      accountingType: \"budget\",\n      industry: null,\n      centralizedOffice: \"ГКУ «МЦБУ»\"\n    },\n    {\n      id: 3,\n      name: \"ГБУ Жилищник района\",\n      inn: \"7922591577\",\n      kpp: \"770301001\",\n      accountingType: \"accounting\",\n      industry: \"Жилищно-коммунальное хозяйство\",\n      centralizedOffice: \"ГКУ «ЦБ ДЖКХ»\"\n    },\n    {\n      id: 4,\n      name: \"ГБУ Школа здоровья\",\n      inn: \"7789010031\",\n      kpp: \"770101001\",\n      accountingType: \"accounting\",\n      industry: \"Образование\",\n      centralizedOffice: \"ГКУ «ЦБ ДОНМ»\"\n    },\n    {\n      id: 5,\n      name: \"ГАУ Новации и кадры\",\n      inn: \"7765230100\",\n      kpp: \"770301001\",\n      accountingType: \"accounting\",\n      industry: null,\n      centralizedOffice: \"ГКУ «ЦБ предпринимательства»\"\n    }\n  ];\n\n  private policySections: PolicySection[] = [\n    {\n      id: 1,\n      sectionNumber: \"1.1.1\",\n      title: \"Общие положения\",\n      content: \"Учетная политика субъекта централизованного учета для целей бюджетного/бухгалтерского учета (далее – учетная политика) сформирована в соответствии с требованиями законодательства Российской Федерации о бухгалтерском учете, федеральных стандартов бухгалтерского учета государственных финансов, иными нормативными правовыми актами и разъяснениями уполномоченных органов государственной власти Российской Федерации, города Москвы, регулирующими порядок организации и ведения учета, составления отчетности.\\n\\nВ состав учетной политики включены следующие приложения:\\nприложение 1 «Рабочий план счетов бухгалтерского учета»;\\nприложение 2 «Альбом неунифицированных форм первичной учетной документации»;\\nприложение 3 «График документооборота»;\\nприложение 4 «Положение об инвентаризации активов и обязательств»;\\nприложение 5 «Положение о комиссии по поступлению и выбытию активов»;\\nприложение 6 «Корреспонденция счетов бухгалтерского учета фактов хозяйственной жизни»;\\nприложение 7 «Положение о расчетах с подотчетными лицами».\\n\\nУчетная политика формируется централизованной бухгалтерией, утверждается руководителем централизованной бухгалтерии и размещается на официальном сайте централизованной бухгалтерии в информационно-телекоммуникационной сети Интернет.\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: false,\n      industries: null\n    },\n    {\n      id: 2,\n      sectionNumber: \"1.1.2\",\n      title: \"Порядок внесения изменений в учетную политику\",\n      content: \"При необходимости внесения изменений в учетную политику, в том числе по инициативе субъекта централизованного учета (например, при изменении условий деятельности, эксплуатации активов, критериев оценки и т.п.), а также в связи с изменениями законодательства Российской Федерации о бухгалтерском учете, нормативных правовых актов, регулирующих ведение учета и составление отчетности, централизованная бухгалтерия разрабатывает проект изменений в стандартизированную учетную политику для целей бюджетного/бухгалтерского учета органов исполнительной власти и государственных учреждений города Москвы.\\n\\nИзменения в учетную политику оформляются отдельным приказом руководителя централизованной бухгалтерии одним из указанных способов:\\n- В случае если изменения кардинально изменяют первоначальные положения учетной политики - утверждается новая редакция учетной политики с отменой старой. Кардинальными считаются изменения, затрагивающие более 50 процентов текста или разделов учетной политики.\\n- В иных случаях изменения оформляются путем их внесения в действующую редакцию учетной политики.\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: false,\n      industries: null\n    },\n    {\n      id: 3,\n      sectionNumber: \"1.1.3\",\n      title: \"Оценочные значения\",\n      content: \"Оценочные значения показателя, необходимого для ведения учета и/или отражаемого в отчетности, рассчитываются (оценочно определяются) основываясь, в том числе, на профессиональных суждениях ответственных должностных лиц субъекта централизованного учета, централизованной бухгалтерии, полномочных (компетентных) принимать решения в тех или иных вопросах, обладающих специальными знаниями, опытом, а при отсутствии таких лиц – на основании экспертных заключений специализированных организаций.\\n\\nПрофессиональное суждение выносится специалистом (должностным лицом) с учетом требований нормативных правовых актов, регулирующих вопросы предметной области, в отношении которой определяется оценочное значение, специфики деятельности субъекта централизованного учета, а также положений настоящей учетной политики.\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: false,\n      industries: null\n    },\n    {\n      id: 4,\n      sectionNumber: \"1.2\",\n      title: \"Организация учета\",\n      content: \"Учет субъекта централизованного учета ведется автоматизированным способом на базе универсальной автоматизированной системы бюджетного учета (платформа «1С») посредством использования централизованной бухгалтерией и субъектами централизованного учета статусной модели, реализуемой путем настройки Департаментом информационных технологий города Москвы функциональных блоков (подсистем) в соответствии с Соглашением.\\n\\nУчет субъекта централизованного учета ведется в соответствии с Рабочим планом счетов бухгалтерского учета, содержащим синтетические и аналитические счета, разработанным на основе Единого плана счетов бухгалтерского учета для органов государственной власти.\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: false,\n      industries: null\n    },\n    {\n      id: 5,\n      sectionNumber: \"1.3\",\n      title: \"Правила документооборота и технология обработки учетной информации\",\n      content: \"Для ведения учета применяются:\\n- унифицированные формы первичных учетных документов, утвержденные приказом Минфина России от 30.03.2015 № 52н;\\n- унифицированные формы первичных учетных документов, утвержденные приказом Минфина России от 15.04.2021 № 61н;\\n- иные унифицированные формы первичных документов, утвержденные уполномоченными государственными органами;\\n- самостоятельно разработанные формы документов, содержащие обязательные реквизиты.\\n\\nПорядок нумерации отдельных видов документов устанавливается в зависимости от типа документа с возобновлением нумерации в начале года.\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: false,\n      industries: null\n    },\n    {\n      id: 6,\n      sectionNumber: \"2.1.1.2.4\",\n      title: \"Объекты благоустройства\",\n      content: \"В соответствии с нормами Закона г. Москвы от 30.04.2014 № 18 «О благоустройстве в городе Москве» объектами благоустройства являются: территория города Москвы с расположенными на ней элементами объектов благоустройства, внешние поверхности зданий, строений, сооружений (в том числе крыши, фасады), объекты, не являющиеся объектами капитального строительства.\\n\\nК элементам объектов благоустройства относятся конструктивные и функциональные составляющие объектов благоустройства, определяющие их внешний вид, обеспечивающие визуальное восприятие объектов благоустройства.\\n\\nК работам по благоустройству территории относятся: устройство покрытий (асфальтирование, укладка плитки), озеленение (газоны, клумбы), устройство освещения, инженерная подготовка, установка малых архитектурных форм (детские и спортивные комплексы, скамейки, урны, ограждения).\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: true,\n      industries: [\"Жилищно-коммунальное хозяйство\", \"Транспорт\", \"Дорожное хозяйство\"]\n    },\n    {\n      id: 7,\n      sectionNumber: \"1.3.2\",\n      title: \"Особенности применения первичных документов\",\n      content: \"Извещение (ф. 0504805) оформляется как первичный учетный документ в целях отражения взаимосвязанных операций, возникающих при расчетах между администратором доходов по начислению доходов и администратором, осуществляющим полномочия по администрированию кассовых поступлений.\\n\\nБухгалтерская справка (ф. 0504833) составляется для отражения в учете совершаемых операций в следующих случаях: при перерегистрации обязательств, при принятии к учету права пользования активом, при исправлении ошибок в учете, при формировании резерва предстоящих расходов.\\n\\nРасчетные листки формируются централизованной бухгалтерией в УАИС Бюджетный учет. Выдача расчетных листков работникам субъекта централизованного учета осуществляется в порядке, установленном Соглашением.\",\n      budgetAccounting: true,\n      businessAccounting: true,\n      industrySpecific: false,\n      industries: null\n    }\n  ];\n\n  private generatedPolicies: GeneratedPolicy[] = [];\n  private nextOrganizationId = 6;\n  private nextGeneratedPolicyId = 1;\n\n  async getOrganizations(): Promise<Organization[]> {\n    return [...this.organizations];\n  }\n\n  async getOrganization(id: number): Promise<Organization | null> {\n    return this.organizations.find(org => org.id === id) || null;\n  }\n\n  async createOrganization(data: InsertOrganization): Promise<Organization> {\n    const newOrganization: Organization = {\n      id: this.nextOrganizationId++,\n      ...data\n    };\n    this.organizations.push(newOrganization);\n    return newOrganization;\n  }\n\n  async getPolicySections(): Promise<PolicySection[]> {\n    return [...this.policySections];\n  }\n\n  async getPolicySection(id: number): Promise<PolicySection | null> {\n    return this.policySections.find(section => section.id === id) || null;\n  }\n\n  async getGeneratedPolicies(): Promise<GeneratedPolicy[]> {\n    return [...this.generatedPolicies];\n  }\n\n  async createGeneratedPolicy(data: InsertGeneratedPolicy): Promise<GeneratedPolicy> {\n    const newPolicy: GeneratedPolicy = {\n      id: this.nextGeneratedPolicyId++,\n      ...data\n    };\n    this.generatedPolicies.push(newPolicy);\n    return newPolicy;\n  }\n\n  async getGeneratedPolicy(id: number): Promise<GeneratedPolicy | null> {\n    return this.generatedPolicies.find(policy => policy.id === id) || null;\n  }\n}\n","size_bytes":16818},"shared/schema.ts":{"content":"import { pgTable, serial, text, boolean, integer } from \"drizzle-orm/pg-core\";\nimport { createInsertSchema } from \"drizzle-zod\";\nimport { z } from \"zod\";\n\nexport const organizations = pgTable(\"organizations\", {\n  id: serial(\"id\").primaryKey(),\n  name: text(\"name\").notNull(),\n  inn: text(\"inn\").notNull(),\n  kpp: text(\"kpp\").notNull(),\n  accountingType: text(\"accounting_type\", { enum: [\"budget\", \"accounting\"] }).notNull(),\n  industry: text(\"industry\"),\n  centralizedOffice: text(\"centralized_office\").notNull(),\n});\n\nexport const insertOrganizationSchema = createInsertSchema(organizations).omit({\n  id: true,\n});\n\nexport type InsertOrganization = z.infer<typeof insertOrganizationSchema>;\nexport type Organization = typeof organizations.$inferSelect;\n\nexport const policySections = pgTable(\"policy_sections\", {\n  id: serial(\"id\").primaryKey(),\n  sectionNumber: text(\"section_number\").notNull(),\n  title: text(\"title\").notNull(),\n  content: text(\"content\").notNull(),\n  budgetAccounting: boolean(\"budget_accounting\").notNull().default(false),\n  businessAccounting: boolean(\"business_accounting\").notNull().default(false),\n  industrySpecific: boolean(\"industry_specific\").notNull().default(false),\n  industries: text(\"industries\").array(),\n});\n\nexport const insertPolicySectionSchema = createInsertSchema(policySections).omit({\n  id: true,\n});\n\nexport type InsertPolicySection = z.infer<typeof insertPolicySectionSchema>;\nexport type PolicySection = typeof policySections.$inferSelect;\n\nexport const generatedPolicies = pgTable(\"generated_policies\", {\n  id: serial(\"id\").primaryKey(),\n  organizationId: integer(\"organization_id\").notNull(),\n  selectedSections: integer(\"selected_sections\").array().notNull(),\n  generatedDate: text(\"generated_date\").notNull(),\n  status: text(\"status\", { enum: [\"draft\", \"approved\"] }).notNull(),\n});\n\nexport const insertGeneratedPolicySchema = createInsertSchema(generatedPolicies).omit({\n  id: true,\n});\n\nexport type InsertGeneratedPolicy = z.infer<typeof insertGeneratedPolicySchema>;\nexport type GeneratedPolicy = typeof generatedPolicies.$inferSelect;\n","size_bytes":2090}},"version":1}